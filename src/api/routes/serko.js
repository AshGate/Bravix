import express from 'express';
import { serverConfigs, getServerConfig, ticketPanels, getServerPanels } from '../index.js';

const router = express.Router();

// Middleware de v√©rification d'authentification
const requireAuth = (req, res, next) => {
    const userId = req.headers['x-user-id'] || req.query.userId;
    
    // Pour l'instant, on accepte 'admin' comme utilisateur valide
    if (userId === 'admin' || userId === process.env.ADMIN_USER_ID) {
        req.userId = userId;
        next();
    } else {
        console.log(`üö® Tentative d'acc√®s non autoris√© par l'utilisateur ${userId}`);
        res.status(403).json({ error: 'Acc√®s refus√©. Authentification requise.' });
    }
};

// Route pour obtenir la configuration d'un serveur
router.get('/config', async (req, res) => {
    try {
        const guildId = req.query.guild;
        console.log(`‚öôÔ∏è Configuration demand√©e pour le serveur: ${guildId}`);
        
        if (!guildId) {
            console.error('‚ùå ID de serveur manquant');
            return res.status(400).json({ error: 'ID de serveur requis' });
        }

        // Importer le client depuis l'index principal
        const { client } = await import('../index.js');

        if (!client.isReady()) {
            console.error('‚ùå Bot Discord non connect√©');
            return res.status(503).json({ error: 'Bot Discord non connect√©. V√©rifiez la connexion.' });
        }

        console.log(`üîç Recherche du serveur ${guildId}...`);
        console.log(`üìä Total serveurs en cache: ${client.guilds.cache.size}`);
        
        let guild = client.guilds.cache.get(guildId);
        
        if (!guild) {
            console.log(`‚ö†Ô∏è Serveur ${guildId} non trouv√© dans le cache, tentative de fetch...`);
            
            try {
                await client.guilds.fetch();
                console.log(`üîÑ Cache des guildes rafra√Æchi. Nouveau total: ${client.guilds.cache.size}`);
                
                guild = client.guilds.cache.get(guildId);
                
                if (!guild) {
                    console.log(`üîç Tentative de fetch direct du serveur ${guildId}...`);
                    guild = await client.guilds.fetch(guildId);
                    console.log(`‚úÖ Serveur trouv√© via fetch direct: ${guild.name}`);
                }
            } catch (fetchError) {
                console.error(`‚ùå Impossible de r√©cup√©rer le serveur ${guildId}:`, fetchError.message);
                
                if (fetchError.code === 50001) {
                    return res.status(403).json({ 
                        error: 'Le bot n\'a pas acc√®s √† ce serveur. V√©rifiez que le bot est bien invit√© sur le serveur avec les bonnes permissions.' 
                    });
                } else if (fetchError.code === 10004) {
                    return res.status(404).json({ 
                        error: 'Serveur introuvable. V√©rifiez que l\'ID du serveur est correct et que le serveur existe toujours.' 
                    });
                } else {
                    return res.status(404).json({ 
                        error: `Serveur non trouv√© ou bot non pr√©sent sur ce serveur. Code d'erreur: ${fetchError.code || 'UNKNOWN'}` 
                    });
                }
            }
        }

        if (!guild) {
            console.error(`‚ùå Serveur ${guildId} d√©finitivement introuvable`);
            return res.status(404).json({ 
                error: 'Serveur non trouv√©. Le bot n\'est peut-√™tre pas pr√©sent sur ce serveur ou l\'ID est incorrect.' 
            });
        }

        console.log(`‚úÖ Serveur trouv√©: ${guild.name} (${guild.memberCount} membres)`);

        const config = getServerConfig(guildId);
        
        const allChannels = guild.channels.cache;
        console.log(`üîç Analyse du serveur ${guild.name}:`);
        console.log(`   - Total canaux: ${allChannels.size}`);

        const textChannels = allChannels
            .filter(channel => {
                const isTextChannel = channel.type === 0;
                if (isTextChannel) {
                    console.log(`   - Canal texte trouv√©: #${channel.name} (${channel.id})`);
                }
                return isTextChannel;
            })
            .map(channel => ({
                id: channel.id,
                name: channel.name,
                type: channel.type,
                position: channel.position || 0
            }))
            .sort((a, b) => a.position - b.position);

        const categories = allChannels
            .filter(channel => {
                const isCategory = channel.type === 4;
                if (isCategory) {
                    console.log(`   - Cat√©gorie trouv√©e: ${channel.name} (${channel.id})`);
                }
                return isCategory;
            })
            .map(channel => ({
                id: channel.id,
                name: channel.name,
                type: channel.type,
                position: channel.position || 0
            }))
            .sort((a, b) => a.position - b.position);

        const roles = guild.roles.cache
            .filter(role => role.name !== '@everyone' && !role.managed)
            .map(role => ({
                id: role.id,
                name: role.name,
                color: role.color,
                position: role.position
            }))
            .sort((a, b) => b.position - a.position);

        const guildData = {
            id: guild.id,
            name: guild.name,
            memberCount: guild.memberCount,
            channels: [...textChannels, ...categories],
            textChannels: textChannels,
            categories: categories,
            roles: roles
        };

        console.log(`‚úÖ Configuration envoy√©e pour ${guild.name}:`);
        console.log(`   - Canaux texte: ${textChannels.length}`);
        console.log(`   - Cat√©gories: ${categories.length}`);
        console.log(`   - R√¥les: ${roles.length}`);

        res.json({
            config: config,
            guild: guildData
        });
    } catch (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration de la configuration:', error);
        res.status(500).json({ error: 'Erreur serveur: ' + error.message });
    }
});

// Route pour sauvegarder la configuration
router.post('/config', requireAuth, (req, res) => {
    try {
        const guildId = req.query.guild;
        const newConfig = req.body;
        
        console.log(`üíæ Sauvegarde de configuration pour ${guildId}:`, newConfig);
        
        if (!guildId) {
            return res.status(400).json({ error: 'ID de serveur requis' });
        }

        serverConfigs.set(guildId, newConfig);
        
        console.log(`‚úÖ Configuration mise √† jour pour ${guildId}`);
        
        res.json({ success: true, message: 'Configuration sauvegard√©e avec succ√®s' });
    } catch (error) {
        console.error('‚ùå Erreur lors de la sauvegarde de la configuration:', error);
        res.status(500).json({ error: 'Erreur lors de la sauvegarde: ' + error.message });
    }
});

// Route pour obtenir les panneaux
router.get('/panels', (req, res) => {
    try {
        const guildId = req.query.guild;
        
        if (!guildId) {
            return res.status(400).json({ error: 'ID de serveur requis' });
        }

        const panels = getServerPanels(guildId);
        const panelsArray = Array.from(panels.values());
        
        console.log(`üìã ${panelsArray.length} panneaux demand√©s pour ${guildId}`);
        res.json(panelsArray);
    } catch (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration des panneaux:', error);
        res.status(500).json({ error: 'Erreur serveur: ' + error.message });
    }
});

// Route pour sauvegarder un panneau
router.post('/panels', requireAuth, async (req, res) => {
    try {
        const guildId = req.query.guild;
        const panelData = req.body;
        
        if (!guildId) {
            return res.status(400).json({ error: 'ID de serveur requis' });
        }

        const panelId = `panel_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        const panel = {
            id: panelId,
            guildId: guildId,
            ...panelData,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            messageId: null,
            channelId: panelData.channelId
        };

        const panels = getServerPanels(guildId);
        panels.set(panelId, panel);
        
        console.log(`üíæ Panneau sauvegard√©: ${panelId} pour ${guildId}`);
        
        res.json({ 
            success: true, 
            panel: panel,
            message: 'Panneau sauvegard√© avec succ√®s' 
        });
    } catch (error) {
        console.error('‚ùå Erreur lors de la sauvegarde du panneau:', error);
        res.status(500).json({ error: 'Erreur lors de la sauvegarde: ' + error.message });
    }
});

// Route pour mettre √† jour un panneau
router.put('/panels/:panelId', requireAuth, async (req, res) => {
    try {
        const guildId = req.query.guild;
        const panelId = req.params.panelId;
        const panelData = req.body;
        
        if (!guildId) {
            return res.status(400).json({ error: 'ID de serveur requis' });
        }

        const panels = getServerPanels(guildId);
        const existingPanel = panels.get(panelId);
        
        if (!existingPanel) {
            return res.status(404).json({ error: 'Panneau non trouv√©' });
        }

        const updatedPanel = {
            ...existingPanel,
            ...panelData,
            updatedAt: new Date().toISOString()
        };

        panels.set(panelId, updatedPanel);
        
        console.log(`‚úèÔ∏è Panneau mis √† jour: ${panelId} pour ${guildId}`);
        
        res.json({ 
            success: true, 
            panel: updatedPanel,
            message: 'Panneau mis √† jour avec succ√®s' 
        });
    } catch (error) {
        console.error('‚ùå Erreur lors de la mise √† jour du panneau:', error);
        res.status(500).json({ error: 'Erreur lors de la mise √† jour: ' + error.message });
    }
});

// Route pour supprimer un panneau
router.delete('/panels/:panelId', requireAuth, async (req, res) => {
    try {
        const guildId = req.query.guild;
        const panelId = req.params.panelId;
        
        if (!guildId) {
            return res.status(400).json({ error: 'ID de serveur requis' });
        }

        const panels = getServerPanels(guildId);
        const panel = panels.get(panelId);
        
        if (!panel) {
            return res.status(404).json({ error: 'Panneau non trouv√©' });
        }

        panels.delete(panelId);
        
        console.log(`üóëÔ∏è Panneau supprim√©: ${panelId} pour ${guildId}`);
        
        res.json({ 
            success: true, 
            message: 'Panneau supprim√© avec succ√®s' 
        });
    } catch (error) {
        console.error('‚ùå Erreur lors de la suppression du panneau:', error);
        res.status(500).json({ error: 'Erreur lors de la suppression: ' + error.message });
    }
});

// Route pour envoyer un panneau de tickets
router.post('/send-ticket-panel', requireAuth, async (req, res) => {
    try {
        const guildId = req.query.guild;
        const { title, description, color, buttons, channelId, panelId } = req.body;
        
        console.log(`üì§ Envoi de panneau pour ${guildId} dans le canal ${channelId}`);
        
        if (!guildId) {
            return res.status(400).json({ error: 'ID de serveur requis' });
        }

        // Importer le client depuis l'index principal
        const { client } = await import('../index.js');

        if (!client.isReady()) {
            return res.status(503).json({ error: 'Bot Discord non connect√©' });
        }

        const guild = client.guilds.cache.get(guildId);
        if (!guild) {
            return res.status(404).json({ error: 'Serveur non trouv√© ou bot non pr√©sent' });
        }

        const channel = guild.channels.cache.get(channelId);
        if (!channel) {
            return res.status(404).json({ error: 'Canal non trouv√©' });
        }

        const botMember = guild.members.cache.get(client.user.id);
        if (!channel.permissionsFor(botMember).has(['SendMessages', 'EmbedLinks'])) {
            return res.status(403).json({ error: 'Le bot n\'a pas les permissions n√©cessaires dans ce canal' });
        }

        const embed = {
            color: parseInt(color, 16),
            title: title,
            description: description,
            timestamp: new Date().toISOString(),
            footer: {
                text: 'Serko Ticket System'
            }
        };

        const components = [];
        if (buttons && buttons.length > 0) {
            for (let i = 0; i < buttons.length; i += 5) {
                const row = {
                    type: 1,
                    components: buttons.slice(i, i + 5).map(button => ({
                        type: 2,
                        style: getButtonStyle(button.style),
                        label: button.label,
                        custom_id: `serko_ticket_${button.category}_${button.id}`
                    }))
                };
                components.push(row);
            }
        }

        const sentMessage = await channel.send({
            embeds: [embed],
            components: components
        });

        if (panelId) {
            const panels = getServerPanels(guildId);
            const panel = panels.get(panelId);
            
            if (panel) {
                panel.messageId = sentMessage.id;
                panel.sentAt = new Date().toISOString();
                panels.set(panelId, panel);
                console.log(`üîó Message ID ${sentMessage.id} associ√© au panneau ${panelId}`);
            }
        }

        console.log(`‚úÖ Panneau de tickets envoy√© dans #${channel.name} (${guild.name})`);
        
        res.json({ 
            success: true, 
            message: 'Panneau de tickets envoy√© avec succ√®s',
            messageId: sentMessage.id,
            channelId: channelId
        });
    } catch (error) {
        console.error('‚ùå Erreur lors de l\'envoi du panneau:', error);
        res.status(500).json({ error: 'Erreur lors de l\'envoi du panneau: ' + error.message });
    }
});

// Fonction utilitaire pour convertir le style de bouton
const getButtonStyle = (style) => {
    switch (style) {
        case 'primary': return 1;
        case 'secondary': return 2;
        case 'success': return 3;
        case 'danger': return 4;
        default: return 2;
    }
};

export default router;